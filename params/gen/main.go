package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"regexp"
	"strings"
	"unicode"
)

// Regex to find the script block containing the language data
var scriptRegex = regexp.MustCompile(`AF_initDataCallback\({key: 'ds:3'[^>]*?data:(.*?),\s*sideChannel:`)

// Removed langRegex as we will use JSON parsing now
// var langRegex = regexp.MustCompile(`\["([^"]+)","([^"]+)"\]`)

// SanitizeName converts a language name into a valid Go identifier in SCREAMING_SNAKE_CASE.
func SanitizeName(name string) string {
	// Initial cleanup: Replace ( with _, remove ), remove spaces
	name = strings.ReplaceAll(name, "(", "_")
	name = strings.ReplaceAll(name, ")", "")
	name = strings.ReplaceAll(name, " ", "")

	// Use a builder to construct the snake_case name
	var sb strings.Builder
	var prev rune

	for i, r := range name {
		// Keep only ASCII letters, digits, and the underscore
		if !((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_') {
			continue // Skip other characters like Ê¼ or -
		}

		// Insert underscore before uppercase letters that follow a lowercase letter or digit,
		// or before an uppercase letter that follows another uppercase letter and precedes a lowercase one (e.g., ID Indonesian -> ID_INDONESIAN)
		if i > 0 && r != '_' && prev != '_' { // Don't add underscore if previous was already one
			if (unicode.IsUpper(r) && !unicode.IsUpper(prev)) ||
				(unicode.IsUpper(r) && unicode.IsUpper(prev) && i+1 < len(name) && unicode.IsLower(rune(name[i+1]))) {
				sb.WriteRune('_')
			}
		}

		// Append the character (will be uppercased later)
		sb.WriteRune(r)
		prev = r
	}

	// Convert the entire result to uppercase
	finalName := strings.ToUpper(sb.String())

	// Clean up potential double underscores resulting from initial replacements
	finalName = strings.ReplaceAll(finalName, "__", "_")

	// Ensure the identifier starts with a letter or underscore
	if len(finalName) > 0 && unicode.IsDigit(rune(finalName[0])) {
		finalName = "_" + finalName // Prepend underscore if starts with digit
	}

	return finalName
}

func main() {
	// Fetch the content from translate.google.com
	fmt.Println("Fetching language data from https://translate.google.com ...")
	resp, err := http.Get("https://translate.google.com")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error fetching URL: %v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		fmt.Fprintf(os.Stderr, "Error fetching URL: Status code %d\n", resp.StatusCode)
		os.Exit(1)
	}

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading response body: %v\n", err)
		os.Exit(1)
	}
	bodyString := string(bodyBytes)

	// Extract the relevant JavaScript data block
	scriptMatches := scriptRegex.FindStringSubmatch(bodyString)
	if len(scriptMatches) < 2 {
		fmt.Fprintln(os.Stderr, "Error: Could not find the language data script block in the HTML.")
		os.Exit(1)
	}
	extractedData := scriptMatches[1] // Get the data part

	// --- Unmarshal the extracted data ---
	var rawData [][]interface{} // Outer structure: array of (at least) two elements
	if err := json.Unmarshal([]byte(extractedData), &rawData); err != nil {
		fmt.Fprintf(os.Stderr, "Error unmarshalling JSON data: %v\n", err)
		// Optionally print the data that failed to parse:
		// fmt.Fprintf(os.Stderr, "Data: %s\n", extractedData)
		os.Exit(1)
	}

	if len(rawData) == 0 || len(rawData[0]) == 0 {
		fmt.Fprintln(os.Stderr, "Error: Unmarshalled data structure is empty or invalid.")
		os.Exit(1)
	}

	// Assume the first element of the outer array contains the language list
	languageListRaw := rawData[0] // Directly use the first element, which is []interface{}
	// --- End Unmarshal ---

	// Create the output directory if it doesn't exist
	if err := os.MkdirAll("params/language", 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error creating directory params/language: %v\n", err)
		os.Exit(1)
	}

	// Create the output file (relative to the project root)
	outFile, err := os.Create("params/language/const.go")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating file params/language/const.go: %v\n", err)
		os.Exit(1)
	}
	defer outFile.Close()

	writer := bufio.NewWriter(outFile)

	// Write package declaration and comment
	_, _ = writer.WriteString("// Code generated by go generate; DO NOT EDIT.\n")
	_, _ = writer.WriteString("// This file was generated based on data fetched from https://translate.google.com\n")
	_, _ = writer.WriteString("package language // Changed package name\n\n")
	_, _ = writer.WriteString("const (\n")

	// --- Generate const definitions from unmarshaled data ---
	var languagesFound bool
	for _, item := range languageListRaw {
		langPair, ok := item.([]interface{}) // Each item is a pair [code, name]
		if !ok || len(langPair) != 2 {
			fmt.Fprintf(os.Stderr, "Warning: Skipping invalid item in language list: %v\n", item)
			continue
		}

		codeRaw, codeOk := langPair[0].(string)
		nameRaw, nameOk := langPair[1].(string)

		if !codeOk || !nameOk {
			fmt.Fprintf(os.Stderr, "Warning: Skipping item with non-string code/name: %v\n", langPair)
			continue
		}

		code := codeRaw
		name := nameRaw

		// Skip "auto" and "Detect language"
		if code == "auto" {
			continue
		}

		constName := SanitizeName(name)
		// Prevent identifiers starting with a digit
		if len(constName) > 0 && unicode.IsDigit(rune(constName[0])) {
			constName = "_" + constName
		}

		// Write the constant definition
		_, _ = writer.WriteString(fmt.Sprintf("\t%s = \"%s\" // %s\n", constName, code, name))
		languagesFound = true
	}
	// --- End Generate ---

	if !languagesFound {
		fmt.Fprintln(os.Stderr, "Error: No valid language definitions were generated.")
		os.Exit(1)
	}

	_, _ = writer.WriteString(")\n")

	// Flush the buffer to ensure everything is written to the file
	if err := writer.Flush(); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing to file languages.go: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Successfully generated params/languages.go from live data using JSON parsing")
}
